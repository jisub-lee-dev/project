---
globs: "packages/db/**/*"
alwaysApply: false
---
# 데이터베이스 개발 가이드

## Prisma 스키마 설계

### 기본 원칙

- 명확하고 일관된 네이밍 사용
- 관계 설정 시 성능 고려
- 인덱스 적절히 활용
- 데이터 무결성 보장

### 현재 프로젝트 스키마 구조

```prisma
// 현재 구현된 실제 스키마
model User {
  id        String    @id @default(cuid())
  email     String    @unique
  name      String?
  image     String?
  products  Product[]
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@map("users")
}

model Product {
  id          String   @id @default(cuid())
  name        String
  description String?
  price       Decimal  @db.Decimal(10, 2)
  category    String?
  inStock     Boolean  @default(true)
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("products")
}
```

### 새 모델 추가 시 템플릿

```prisma
model NewModel {
  // 기본 필드 (필수)
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // 비즈니스 필드
  name      String
  isActive  Boolean  @default(true)

  // 관계 (필요시)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // 인덱스 (성능 최적화)
  @@index([userId])
  @@index([createdAt])
  @@map("new_models")
}
```

### 네이밍 규칙

- **모델명**: PascalCase (User, BlogPost)
- **필드명**: camelCase (firstName, createdAt)
- **테이블명**: snake_case (users, blog_posts) - `@@map` 사용
- **관계명**: 복수형 사용 (posts, comments)

### 데이터 타입 선택

```prisma
// 문자열
name     String           // VARCHAR(191)
content  String  @db.Text // TEXT
slug     String  @db.VarChar(100) // VARCHAR(100)

// 숫자
age      Int              // INTEGER
price    Decimal @db.Decimal(10, 2) // DECIMAL(10,2)
rating   Float            // DOUBLE

// 날짜/시간
createdAt DateTime @default(now())
updatedAt DateTime @updatedAt
birthDate DateTime @db.Date

// 불린
isActive  Boolean @default(true)

// JSON (PostgreSQL)
metadata  Json?

// 열거형
enum UserRole {
  USER
  ADMIN
  MODERATOR
}

role UserRole @default(USER)
```

## 관계 설계

### 일대일 관계

```prisma
model User {
  id      String   @id @default(cuid())
  profile Profile?
}

model Profile {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
}
```

### 일대다 관계

```prisma
model User {
  id    String @id @default(cuid())
  posts Post[]
}

model Post {
  id       String @id @default(cuid())
  authorId String
  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)
}
```

### 다대다 관계

```prisma
model Post {
  id   String @id @default(cuid())
  tags Tag[]
}

model Tag {
  id    String @id @default(cuid())
  posts Post[]
}

// 또는 명시적 중간 테이블
model PostTag {
  postId String
  tagId  String
  post   Post   @relation(fields: [postId], references: [id])
  tag    Tag    @relation(fields: [tagId], references: [id])

  @@id([postId, tagId])
}
```

### 삭제 동작 설정

```prisma
// Cascade: 부모 삭제 시 자식도 삭제
author User @relation(fields: [authorId], references: [id], onDelete: Cascade)

// Restrict: 자식이 있으면 부모 삭제 불가
author User @relation(fields: [authorId], references: [id], onDelete: Restrict)

// SetNull: 부모 삭제 시 외래키를 NULL로 설정
author User? @relation(fields: [authorId], references: [id], onDelete: SetNull)
```

## 인덱스 최적화

### 단일 컬럼 인덱스

```prisma
model User {
  email String @unique  // 자동으로 인덱스 생성
  name  String

  @@index([name])       // 명시적 인덱스
}
```

### 복합 인덱스

```prisma
model Post {
  authorId  String
  published Boolean
  createdAt DateTime

  // 복합 인덱스 - 순서 중요!
  @@index([published, createdAt])
  @@index([authorId, published])
}
```

### 부분 인덱스 (PostgreSQL)

```prisma
model Post {
  published Boolean
  title     String

  // 게시된 포스트만 인덱싱
  @@index([title], where: { published: true })
}
```

## 마이그레이션 관리

### 개발 환경

```bash
# 스키마 변경 후 개발 DB에 적용
pnpm db:push

# Prisma 클라이언트 재생성
pnpm db:generate
```

### 프로덕션 환경

```bash
# 마이그레이션 파일 생성
pnpm db:migrate dev --name add_user_profile

# 프로덕션 마이그레이션 적용
pnpm db:migrate deploy
```

### 마이그레이션 파일 예시

```sql
-- CreateTable
CREATE TABLE "users" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "email" TEXT NOT NULL,
    "name" TEXT NOT NULL,

    CONSTRAINT "users_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "users_email_key" ON "users"("email");
CREATE INDEX "users_createdAt_idx" ON "users"("createdAt");
```

## 쿼리 최적화

### 효율적인 데이터 로딩

```typescript
// 필요한 필드만 선택 (현재 스키마에 맞게)
const users = await prisma.user.findMany({
  select: {
    id: true,
    name: true,
    email: true,
    image: true,
    createdAt: true,
    // 민감한 정보 제외
  },
});

// 관계 데이터 포함 (현재 User-Product 관계)
const usersWithProducts = await prisma.user.findMany({
  include: {
    products: {
      where: { inStock: true },
      take: 5,
      orderBy: { createdAt: "desc" },
      select: {
        id: true,
        name: true,
        price: true,
        createdAt: true,
      },
    },
  },
});

// 조건부 포함
const userWithConditionalData = await prisma.user.findUnique({
  where: { id },
  include: {
    products: includeProducts
      ? {
          where: { inStock: true },
          orderBy: { createdAt: "desc" },
        }
      : false,
  },
});
```

### 페이지네이션

```typescript
// 오프셋 기반 페이지네이션 (현재 스키마에 맞게)
async function getUsersPaginated(page: number, limit: number) {
  const [users, total] = await Promise.all([
    prisma.user.findMany({
      skip: (page - 1) * limit,
      take: limit,
      orderBy: { createdAt: "desc" },
      include: {
        _count: { products: true },
      },
    }),
    prisma.user.count(),
  ]);

  return {
    users,
    pagination: {
      page,
      limit,
      total,
      totalPages: Math.ceil(total / limit),
    },
  };
}

// 커서 기반 페이지네이션 (더 효율적)
async function getUsersCursor(cursor?: string, limit: number = 10) {
  const users = await prisma.user.findMany({
    take: limit + 1, // 다음 페이지 존재 여부 확인용
    cursor: cursor ? { id: cursor } : undefined,
    orderBy: { createdAt: "desc" },
    include: {
      _count: { products: true },
    },
  });

  const hasNextPage = users.length > limit;
  const data = hasNextPage ? users.slice(0, -1) : users;

  return {
    users: data,
    nextCursor: hasNextPage ? data[data.length - 1].id : null,
  };
}

// Product 페이지네이션 예시
async function getProductsPaginated(
  page: number,
  limit: number,
  filters?: { category?: string; inStock?: boolean }
) {
  const where = {
    ...(filters?.category && { category: filters.category }),
    ...(filters?.inStock !== undefined && { inStock: filters.inStock }),
  };

  const [products, total] = await Promise.all([
    prisma.product.findMany({
      where,
      skip: (page - 1) * limit,
      take: limit,
      orderBy: { createdAt: "desc" },
      include: {
        user: {
          select: { id: true, name: true, email: true },
        },
      },
    }),
    prisma.product.count({ where }),
  ]);

  return {
    products,
    pagination: {
      page,
      limit,
      total,
      totalPages: Math.ceil(total / limit),
    },
  };
}
```

### 집계 쿼리

```typescript
// 기본 집계 (현재 스키마에 맞게)
const userStats = await prisma.user.aggregate({
  _count: { id: true },
  where: { name: { not: null } },
});

const productStats = await prisma.product.aggregate({
  _count: { id: true },
  _avg: { price: true },
  _sum: { price: true },
  _min: { price: true },
  _max: { price: true },
  where: { inStock: true },
});

// 그룹별 집계 (현재 스키마에 맞게)
const productsByUser = await prisma.product.groupBy({
  by: ["userId"],
  _count: { id: true },
  _avg: { price: true },
  having: {
    id: { _count: { gt: 2 } }, // 2개 이상 제품을 가진 사용자만
  },
});

const productsByCategory = await prisma.product.groupBy({
  by: ["category"],
  _count: { id: true },
  _avg: { price: true },
  where: { inStock: true },
});
```

## 트랜잭션

### 기본 트랜잭션

```typescript
// 현재 스키마에 맞는 트랜잭션 예시
async function createUserWithProducts(
  userData: { email: string; name?: string },
  productData: Array<{ name: string; price: number; description?: string }>
) {
  return await prisma.$transaction(async tx => {
    // 사용자 생성
    const user = await tx.user.create({
      data: {
        email: userData.email,
        name: userData.name,
      },
    });

    // 사용자의 초기 제품들 생성
    const products = await Promise.all(
      productData.map(product =>
        tx.product.create({
          data: {
            ...product,
            userId: user.id,
          },
        })
      )
    );

    return { user, products };
  });
}

// 제품 이전 트랜잭션 예시
async function transferProduct(productId: string, newUserId: string) {
  return await prisma.$transaction(async tx => {
    // 제품 존재 확인
    const product = await tx.product.findUniqueOrThrow({
      where: { id: productId },
    });

    // 새 사용자 존재 확인
    const newUser = await tx.user.findUniqueOrThrow({
      where: { id: newUserId },
    });

    // 제품 소유자 변경
    const updatedProduct = await tx.product.update({
      where: { id: productId },
      data: { userId: newUserId },
    });

    return { product: updatedProduct, newOwner: newUser };
  });
}
```

### 배치 작업

```typescript
// 현재 스키마에 맞는 배치 작업
async function createMultipleUsers(
  userData: Array<{ email: string; name?: string }>
) {
  return await prisma.$transaction(
    userData.map(data =>
      prisma.user.create({
        data,
      })
    )
  );
}

// 또는 createMany 사용 (더 효율적)
async function createUsersInBatch(
  userData: Array<{ email: string; name?: string }>
) {
  return await prisma.user.createMany({
    data: userData,
    skipDuplicates: true, // 중복 시 건너뛰기
  });
}

// 제품 배치 생성
async function createProductsInBatch(
  userId: string,
  productData: Array<{
    name: string;
    price: number;
    description?: string;
    category?: string;
  }>
) {
  return await prisma.product.createMany({
    data: productData.map(product => ({
      ...product,
      userId,
    })),
    skipDuplicates: false,
  });
}
```

## 데이터 시딩

### 시드 스크립트

```typescript
// packages/db/seed.ts
import { PrismaClient } from "@prisma/client";

const db = new PrismaClient();

async function main() {
  // 기본 사용자 생성
  const adminUser = await db.user.upsert({
    where: { email: "admin@example.com" },
    update: {},
    create: {
      email: "admin@example.com",
      name: "Admin User",
      role: "ADMIN",
    },
  });

  // 테스트 데이터 생성
  const testUsers = await Promise.all(
    Array.from({ length: 10 }, (_, i) =>
      db.user.create({
        data: {
          email: `user${i + 1}@example.com`,
          name: `Test User ${i + 1}`,
          posts: {
            create: [
              {
                title: `Post ${i + 1}`,
                content: `Content for post ${i + 1}`,
                published: Math.random() > 0.5,
              },
            ],
          },
        },
      })
    )
  );

  console.log(`Created ${testUsers.length} test users`);
}

main()
  .catch(e => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await db.$disconnect();
  });
```

### package.json 스크립트

```json
{
  "scripts": {
    "db:seed": "tsx seed.ts",
    "db:reset": "prisma migrate reset --force && npm run db:seed"
  }
}
```

## 성능 모니터링

### 쿼리 로깅

```typescript
// packages/db/src/client/client.ts
import { PrismaClient } from "@prisma/client";

const prismaClientSingleton = () => {
  return new PrismaClient({
    log: [
      { emit: "event", level: "query" },
      { emit: "event", level: "error" },
      { emit: "event", level: "warn" },
    ],
  });
};

declare global {
  var prisma: undefined | ReturnType<typeof prismaClientSingleton>;
}

export const prisma = globalThis.prisma ?? prismaClientSingleton();

if (process.env.NODE_ENV !== "production") {
  globalThis.prisma = prisma;
}

// 쿼리 로깅
prisma.$on("query", e => {
  console.log("Query: " + e.query);
  console.log("Duration: " + e.duration + "ms");
});
```

### 연결 풀 설정

```env
# .env
DATABASE_URL="postgresql://user:password@localhost:5432/mydb?connection_limit=20&pool_timeout=20"
```

## 백업 및 복구

### 정기 백업 스크립트

```bash
#!/bin/bash
# scripts/backup-db.sh

DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="./backups"
DB_NAME="myapp"

mkdir -p $BACKUP_DIR

# PostgreSQL 백업
pg_dump $DATABASE_URL > "$BACKUP_DIR/backup_$DATE.sql"

# 오래된 백업 파일 정리 (7일 이상)
find $BACKUP_DIR -name "backup_*.sql" -mtime +7 -delete

echo "Backup completed: backup_$DATE.sql"
```

## 보안 고려사항

### 민감한 데이터 처리

```prisma
model User {
  id       String @id @default(cuid())
  email    String @unique
  password String // 해시된 비밀번호만 저장

  // 민감한 정보는 별도 테이블로 분리
  sensitiveData SensitiveUserData?
}

model SensitiveUserData {
  id     String @id @default(cuid())
  userId String @unique
  ssn    String? // 암호화된 주민번호
  user   User    @relation(fields: [userId], references: [id], onDelete: Cascade)
}
```

### 접근 제어

```typescript
// RLS (Row Level Security) 활용 예시
// PostgreSQL에서 사용자별 데이터 접근 제한

// 사용자는 자신의 데이터만 조회 가능
const userPosts = await db.post.findMany({
  where: {
    authorId: currentUserId, // 항상 현재 사용자 ID로 필터링
  },
});
```

## 테스트

### 데이터베이스 테스트 설정

```typescript
// packages/db/test-setup.ts
import { PrismaClient } from "@prisma/client";

const db = new PrismaClient({
  datasources: {
    db: {
      url: process.env.TEST_DATABASE_URL,
    },
  },
});

export async function setupTestDb() {
  // 테스트 데이터 초기화
  await db.$executeRaw`TRUNCATE TABLE "users" CASCADE`;
  await db.$executeRaw`TRUNCATE TABLE "posts" CASCADE`;
}

export async function teardownTestDb() {
  await db.$disconnect();
}

export { db as testDb };
```

### 테스트 예시

```typescript
import { testDb, setupTestDb, teardownTestDb } from "./test-setup";

describe("User model", () => {
  beforeEach(async () => {
    await setupTestDb();
  });

  afterAll(async () => {
    await teardownTestDb();
  });

  it("should create a user", async () => {
    const user = await testDb.user.create({
      data: {
        email: "test@example.com",
        name: "Test User",
      },
    });

    expect(user.email).toBe("test@example.com");
    expect(user.id).toBeDefined();
  });

  it("should enforce unique email constraint", async () => {
    await testDb.user.create({
      data: { email: "test@example.com", name: "User 1" },
    });

    await expect(
      testDb.user.create({
        data: { email: "test@example.com", name: "User 2" },
      })
    ).rejects.toThrow();
  });
});
```
